基本思路是 BFS 。

所有和 beginWord 差距为 1 的入队，每次出队一个 word ，先检查是否等于 endWord ，否则再入队剩余列表中所有差距为 1 的，以此类推。

其中使用一个 map 来记录每个 word 的深度。

虽然 AC 了，时间复杂度太高，刚过 10% ，复习 BFS 回来继续搞……

## 优化
1. 当列表很长时，依次“比较差值是否为1”的时间复杂度非常高。
针对这种情况，对每次出队的 word ，每次替换其中一个字母组成新的单词，检查列表中是否存在，这样就减少了计算量。

2. 维持一个未访问列表，缩短后续查询的长度。

> 才过了 45% ，但参考其他答案后发现，主要差别是如何对待已访问列表（array vs hash），进而影响深度的计算方式，主要思路没有差异。
