基本思路是 BFS 。

所有和 beginWord 差距为 1 的入队，每次出队一个 word ，先检查是否等于 endWord ，否则再入队剩余列表中所有差距为 1 的，以此类推。

其中使用一个 map 来记录每个 word 的深度。

虽然 AC 了，时间复杂度太高，刚过 10% ，复习 BFS 回来继续搞……

## 优化
1. 当列表很长时，依次“比较差值是否为1”的时间复杂度非常高。
针对这种情况，对每次出队的 word ，每次替换其中一个字母组成新的单词，检查列表中是否存在，这样就减少了计算量。

2. 维持一个未访问列表，缩短后续查询的长度。

3. 到这一步，才过了45%，但参考其他答案（非100%）后发现，主要差别是如何计算深度（array vs hash），主要思路没有差异。果然，更改 length 的计算方式就突破了80%，使用hash 存储每个 word 的深度是相对低效的。

4. 双管齐下，两头一起计算，哪边队列短就先算哪个。不过在 js 中时间降低不明显，换 go 来实现吧。
