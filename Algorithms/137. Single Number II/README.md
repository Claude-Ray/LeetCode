简单的做法就是不用纯位运算，从每一位分别计算和，模3，最终结果就是想要的数。

go 实现略坑的地方是 64 位机的 int 长度也是 64 位，相比其他语言版本，时间复杂度从 32n 变成 64n，直接拉大了和位运算的速度差距。
```go
func singleNumber(nums []int) int {
	res := 0
	var i uint
	for ; i < 64; i++ {
		sum := 0
		for j := 0; j < len(nums); j++ {
			sum += nums[j] >> i & 1
		}
		res |= (sum % 3) << i
	}
	return res
}
```

纯位运算版本参考了 Discuss，理解过程如下。

每一位相加后模3的计算方法，可以简化为
```
0 + 1 = 1
1 + 1 = 2
2 + 1 = 0
```
二进制版本为
```
00 + 01 = 01
01 + 01 = 10
10 + 01 = 00
```
因此，可以设两个临时变量 ones、twos，来保存每一位相加计算的二进制结果的第一位和第二位（从右到左）。

需要实现每次“相加”都按照二进制版本的运算方式来更新 ones 和 twos。对应保存策略即 one 在 two 不为 1 的时候取反，故得出 (one ^ 1) & ^two，反之得到 (two ^ 1) & ^one。
```
two one      two one
0   0   ->   0   1
0   1   ->   1   0
1   0   ->   0   0
```
